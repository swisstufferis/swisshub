-- Swiss Hub - Fluent UI Version (Merged with Femboy Hub features)

-- =========================
-- CLEANUP (overwrite previous run)
-- =========================
do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local CoreGui = game:GetService("CoreGui")

    local oldFluent = CoreGui:FindFirstChild("Fluent")
    if not oldFluent then
        oldFluent = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("Fluent")
    end
    if oldFluent then oldFluent:Destroy() end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local oldShaders = playerGui:FindFirstChild("SwissShaders")
    if oldShaders then oldShaders:Destroy() end

    local Lighting = game:GetService("Lighting")
    for _, obj in pairs(Lighting:GetChildren()) do
        if obj:IsA("ColorCorrectionEffect") and obj.Name == "SwissColorCorrection" then obj:Destroy() end
        if obj:IsA("Sky") == false and obj.Name == "SwissColorCorrection" then obj:Destroy() end
    end

    local oldTag = LocalPlayer:FindFirstChild("SwissHub_Loaded")
    if oldTag then oldTag:Destroy() end

    local tag = Instance.new("BoolValue")
    tag.Name = "SwissHub_Loaded"
    tag.Parent = LocalPlayer

    task.wait(0.1)
end

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local Lighting          = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local InsertService     = game:GetService("InsertService")
local player            = Players.LocalPlayer

-- =========================
-- OWNER DETECTION
-- =========================
local OWNER_USERNAME = "kxnzlieeee"
local isOwner = player.Name:lower() == OWNER_USERNAME:lower()

-- =========================
-- KEY SYSTEM (Non-owners only)
-- =========================
if not isOwner then
    local CORRECT_KEY = "tufferymadebyswiss"

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SwissKeySystem"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = player:WaitForChild("PlayerGui")

    local blur = Instance.new("BlurEffect")
    blur.Size = 24
    blur.Parent = Lighting

    local bg = Instance.new("Frame")
    bg.Size = UDim2.fromOffset(420, 220)
    bg.Position = UDim2.fromScale(0.5, 0.5)
    bg.AnchorPoint = Vector2.new(0.5, 0.5)
    bg.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
    bg.BorderSizePixel = 0
    bg.Parent = screenGui
    Instance.new("UICorner", bg).CornerRadius = UDim.new(0, 12)

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.fromOffset(0, 18)
    title.BackgroundTransparency = 1
    title.Text = "üîë Swiss Hub ‚Äî Key Required"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 16
    title.Font = Enum.Font.GothamBold
    title.Parent = bg

    local sub = Instance.new("TextLabel")
    sub.Size = UDim2.new(1, -40, 0, 30)
    sub.Position = UDim2.fromOffset(20, 55)
    sub.BackgroundTransparency = 1
    sub.Text = "Get the key by joining the Discord server."
    sub.TextColor3 = Color3.fromRGB(180, 180, 180)
    sub.TextSize = 13
    sub.Font = Enum.Font.Gotham
    sub.TextXAlignment = Enum.TextXAlignment.Left
    sub.Parent = bg

    local inputBox = Instance.new("TextBox")
    inputBox.Size = UDim2.new(1, -40, 0, 40)
    inputBox.Position = UDim2.fromOffset(20, 95)
    inputBox.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    inputBox.BorderSizePixel = 0
    inputBox.Text = ""
    inputBox.PlaceholderText = "Enter key here..."
    inputBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
    inputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    inputBox.TextSize = 14
    inputBox.Font = Enum.Font.Gotham
    inputBox.ClearTextOnFocus = false
    inputBox.Parent = bg
    Instance.new("UICorner", inputBox).CornerRadius = UDim.new(0, 8)

    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -40, 0, 20)
    status.Position = UDim2.fromOffset(20, 143)
    status.BackgroundTransparency = 1
    status.Text = ""
    status.TextColor3 = Color3.fromRGB(255, 80, 80)
    status.TextSize = 12
    status.Font = Enum.Font.Gotham
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = bg

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, -40, 0, 36)
    btn.Position = UDim2.fromOffset(20, 165)
    btn.BackgroundColor3 = Color3.fromRGB(120, 60, 180)
    btn.BorderSizePixel = 0
    btn.Text = "Submit Key"
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.TextSize = 14
    btn.Font = Enum.Font.GothamBold
    btn.Parent = bg
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

    local verified = false
    btn.MouseButton1Click:Connect(function()
        local entered = inputBox.Text:lower():gsub("%s+", "")
        if entered == CORRECT_KEY then
            verified = true
            status.TextColor3 = Color3.fromRGB(80, 255, 120)
            status.Text = "‚úÖ Key accepted! Loading..."
            task.wait(1)
            screenGui:Destroy()
            blur:Destroy()
        else
            status.Text = "‚ùå Invalid key. Try again."
            inputBox.Text = ""
        end
    end)

    repeat task.wait(0.1) until verified
end

local Window = Fluent:CreateWindow({
    Title = "Swiss Hub",
    SubTitle = "by swiss",
    TabWidth = 140,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightControl
})

local Tabs = {
    Credits     = Window:AddTab({ Title = "Credits",  Icon = "heart" }),
    Main        = Window:AddTab({ Title = "Main",     Icon = "zap" }),
    CustomMaps  = Window:AddTab({ Title = "Maps",     Icon = "map-pin" }),
    CustomSky   = Window:AddTab({ Title = "Sky",      Icon = "cloud" }),
    EmoteChanger= Window:AddTab({ Title = "Emotes",   Icon = "music-2" }),
    CoolStuff   = Window:AddTab({ Title = "Visual",   Icon = "eye" }),
    Owner       = Window:AddTab({ Title = "Owner",    Icon = "crown" }),
    Settings    = Window:AddTab({ Title = "Settings", Icon = "settings" }),
}

local function Notify(title, content, duration)
    Fluent:Notify({ Title = title, Content = content, Duration = duration or 3 })
end

-- =========================
-- DISCORD LOGGER
-- =========================
task.spawn(function()
    local HttpService = game:GetService("HttpService")
    local MarketplaceService = game:GetService("MarketplaceService")
    local webhookUrl = "https://discord.com/api/webhooks/1475010750887100437/X1PEJDlyaJT5EgpeeRfiIkcCcQYNv8Tf1UXgeSaal1IeIF4iSfj1IlJuadJmukizB2zL"
    local gameName = "Unknown"
    pcall(function() gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name end)
    local data = HttpService:JSONEncode({
        embeds = {{
            title = "üü¢ Swiss Hub ‚Äî Script Executed",
            color = 0x9B59B6,
            fields = {
                { name = "üë§ Username",     value = "@" .. player.Name,         inline = true },
                { name = "üìõ Display Name", value = player.DisplayName,          inline = true },
                { name = "üÜî User ID",      value = tostring(player.UserId),     inline = true },
                { name = "üéÆ Game",         value = gameName,                    inline = false },
                { name = "üîó Profile",      value = "https://www.roblox.com/users/" .. player.UserId .. "/profile", inline = false },
            },
            footer = { text = "Swiss Hub Logger" },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
    })
    pcall(function()
        request({ Url = webhookUrl, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = data })
    end)
end)

-- =========================
-- CREDITS TAB
-- =========================
Tabs.Credits:AddSection("About")
Tabs.Credits:AddParagraph({ Title = "Swiss Hub", Content = "some tuffery made by Swiss heh" })
Tabs.Credits:AddParagraph({ Title = "Version", Content = "v1.3" })
Tabs.Credits:AddParagraph({ Title = "Supported Game", Content = "Evade" })
Tabs.Credits:AddParagraph({ Title = "Last Updated", Content = "2026" })
Tabs.Credits:AddSection("Session")
Tabs.Credits:AddParagraph({ Title = "Loaded For", Content = player.DisplayName .. " (@" .. player.Name .. ")" })

-- =========================
-- CHARACTER HELPER
-- =========================
local character, hrp, humanoid

local function getCharacterAndHrp()
    character = player.Character or player.CharacterAdded:Wait()
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    return character, hrp, humanoid
end
getCharacterAndHrp()

player.CharacterAdded:Connect(function()
    task.wait(0.5)
    getCharacterAndHrp()
end)

-- =========================
-- MAIN TAB ‚Äî EDGE SCRIPT (Femboy Hub full version)
-- =========================
local BOOST_POWER = 80
local MIN_Y_VEL = 1.0
local isEdgeEnabled = false
local edgeConnection = nil

local function isBouncePart(part)
    local kw = {"bounce","boost","launch","jump","pad","ramp","platform"}
    local name = string.lower(part.Name)
    for _, k in pairs(kw) do if name:find(k) then return true end end
    if part.Parent and (part.Parent:IsA("Model") or part.Parent:IsA("Folder")) then
        local pn = string.lower(part.Parent.Name)
        for _, k in pairs(kw) do if pn:find(k) then return true end end
    end
    return false
end

local function applyEdgeBoost()
    if not isEdgeEnabled or not hrp or not humanoid or humanoid.Health <= 0 then return end
    if hrp.AssemblyLinearVelocity.Y < -MIN_Y_VEL then
        local tp = hrp:GetTouchingParts(); local bounce = false
        for _, p in pairs(tp) do if isBouncePart(p) then bounce = true; break end end
        if not bounce and #tp > 0 then
            hrp.AssemblyLinearVelocity = Vector3.new(hrp.AssemblyLinearVelocity.X, 0, hrp.AssemblyLinearVelocity.Z)
                + Vector3.new(0, BOOST_POWER, 0)
        end
    end
end

Tabs.Main:AddSection("Edge Script")

local BoostSlider = Tabs.Main:AddSlider("BoostPowerSlider", {
    Title = "Boost Power", Default = 80, Min = 0, Max = 400, Rounding = 0,
    Callback = function(v) BOOST_POWER = v end,
})
Tabs.Main:AddInput("BoostInput", {
    Title = "Custom Value (0‚Äì400)", Placeholder = "e.g. 120", Numeric = true,
    Callback = function(v)
        local n = tonumber(v); if not n then return end
        n = math.clamp(math.floor(n+0.5), 0, 400); BOOST_POWER = n; BoostSlider:SetValue(n)
    end,
})
Tabs.Main:AddDropdown("BoostPreset", {
    Title = "Quick Preset", Values = {"0","40","80","120","160","200","240","280","320","360","400"}, Default = "80",
    Callback = function(v) local val = tonumber(v); if val then BOOST_POWER = val; BoostSlider:SetValue(val) end end,
})
local EdgeBoostToggle = Tabs.Main:AddToggle("EdgeBoostToggle", {
    Title = "Enable Edge Script", Default = false,
    Callback = function(v)
        isEdgeEnabled = v
        if v then
            getCharacterAndHrp()
            if edgeConnection then edgeConnection:Disconnect() end
            edgeConnection = RunService.Stepped:Connect(applyEdgeBoost)
        else
            if edgeConnection then edgeConnection:Disconnect(); edgeConnection = nil end
        end
    end,
})
Tabs.Main:AddKeybind("EdgeBoostKeybind", {
    Title = "Edge Script Keybind", Mode = "Toggle", Default = "X",
    Callback = function() EdgeBoostToggle:SetValue(not isEdgeEnabled) end,
})

-- =========================
-- MAIN TAB ‚Äî FLY (Femboy Hub version)
-- =========================
local isFlyEnabled = false
local flySpeed = 50
local flyBodyVel = nil
local flyBodyGyro = nil
local flyConn = nil

local function enableFly()
    if not hrp or not humanoid then return end
    isFlyEnabled = true; humanoid.PlatformStand = true
    flyBodyVel = Instance.new("BodyVelocity")
    flyBodyVel.Velocity = Vector3.new(0,0,0); flyBodyVel.MaxForce = Vector3.new(9e9,9e9,9e9)
    flyBodyVel.Parent = hrp
    flyBodyGyro = Instance.new("BodyGyro")
    flyBodyGyro.MaxTorque = Vector3.new(9e9,9e9,9e9); flyBodyGyro.P = 9e4
    flyBodyGyro.CFrame = hrp.CFrame; flyBodyGyro.Parent = hrp
    flyConn = RunService.Heartbeat:Connect(function()
        if not isFlyEnabled or not hrp or not flyBodyVel then return end
        local cam = workspace.CurrentCamera; local dir = Vector3.new(0,0,0); local spd = flySpeed * 12
        if UserInputService:IsKeyDown(Enum.KeyCode.W)         then dir = dir + cam.CFrame.LookVector  end
        if UserInputService:IsKeyDown(Enum.KeyCode.S)         then dir = dir - cam.CFrame.LookVector  end
        if UserInputService:IsKeyDown(Enum.KeyCode.A)         then dir = dir - cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D)         then dir = dir + cam.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space)     then dir = dir + Vector3.new(0,1,0)     end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then dir = dir - Vector3.new(0,1,0)     end
        flyBodyVel.Velocity = if dir.Magnitude > 0 then dir.Unit * spd else Vector3.new(0,0,0)
        flyBodyGyro.CFrame  = cam.CFrame
    end)
end

local function disableFly()
    isFlyEnabled = false
    if flyConn     then flyConn:Disconnect();     flyConn     = nil end
    if flyBodyVel  then flyBodyVel:Destroy();     flyBodyVel  = nil end
    if flyBodyGyro then flyBodyGyro:Destroy();    flyBodyGyro = nil end
    if humanoid    then humanoid.PlatformStand    = false          end
    if hrp then pcall(function() hrp.AssemblyLinearVelocity = Vector3.new(0,0,0) end) end
end

player.CharacterAdded:Connect(function()
    task.wait(1)
    if isFlyEnabled then enableFly() end
end)

Tabs.Main:AddSection("Fly")
local FlySpeedSlider = Tabs.Main:AddSlider("FlySpeedSlider", {
    Title = "Fly Speed", Default = 50, Min = 1, Max = 300, Rounding = 0,
    Callback = function(v) flySpeed = v end,
})
Tabs.Main:AddInput("FlySpeedInput", {
    Title = "Custom Value (1‚Äì300)", Placeholder = "e.g. 75", Numeric = true,
    Callback = function(v)
        local n = tonumber(v); if not n then return end
        n = math.clamp(math.floor(n+0.5), 1, 300); flySpeed = n; FlySpeedSlider:SetValue(n)
    end,
})
Tabs.Main:AddDropdown("FlySpeedPreset", {
    Title = "Quick Preset", Values = {"10","25","50","75","100","125","150","200","300"}, Default = "50",
    Callback = function(v) local val = tonumber(v); if val then flySpeed = val; FlySpeedSlider:SetValue(val) end end,
})
local FlyToggle = Tabs.Main:AddToggle("FlyToggle", {
    Title = "Enable Fly", Default = false,
    Callback = function(v) if v then enableFly() else disableFly() end end,
})
Tabs.Main:AddKeybind("FlyKeybind", {
    Title = "Fly Keybind", Mode = "Toggle", Default = "F",
    Callback = function() FlyToggle:SetValue(not isFlyEnabled) end,
})

-- =========================
-- MAIN TAB ‚Äî TAS (Femboy Hub)
-- =========================
local tasRunning = false
local tasFrames = {}
local tasTimeStart = tick()

local function tasGetChar()
    return player.Character or (player.CharacterAdded:Wait() and player.Character)
end
local function tasStartRecord()
    tasFrames = {}; tasRunning = true; tasTimeStart = tick()
    task.spawn(function()
        while tasRunning do
            RunService.Heartbeat:Wait()
            local c = tasGetChar()
            if c and c:FindFirstChild("HumanoidRootPart") and c:FindFirstChild("Humanoid") then
                table.insert(tasFrames, {c.HumanoidRootPart.CFrame, c.Humanoid:GetState().Value, tick()-tasTimeStart})
            end
        end
    end)
end
local function tasStopRecord() tasRunning = false end
local function tasPlay()
    if #tasFrames == 0 then Notify("TAS", "No recording found! Record first.", 3) return end
    local c = tasGetChar(); if not c then return end
    local timePlay = tick(); local frameCount = #tasFrames; local oldFrame = 1
    local tasLoop
    tasLoop = RunService.Heartbeat:Connect(function()
        local ct = tick()
        if (ct-timePlay) >= tasFrames[frameCount][3] then tasLoop:Disconnect(); return end
        local nf = math.min(oldFrame+60, frameCount)
        for i = oldFrame, nf do
            local f = tasFrames[i]
            if f and f[3] <= ct-timePlay then
                oldFrame = i
                local ch = player.Character
                if ch then
                    if ch:FindFirstChild("HumanoidRootPart") then ch.HumanoidRootPart.CFrame = f[1] end
                    if ch:FindFirstChild("Humanoid") then pcall(function() ch.Humanoid:ChangeState(f[2]) end) end
                end
            end
        end
    end)
end

Tabs.Main:AddSection("TAS (Tool-Assisted Speedrun)")
Tabs.Main:AddParagraph({ Title = "Info", Content = "Record your movement then replay it exactly." })
Tabs.Main:AddButton({ Title = "üî¥ Start Recording", Callback = function() tasStartRecord(); Notify("TAS", "Recording started!", 2) end })
Tabs.Main:AddButton({ Title = "‚èπÔ∏è Stop Recording",  Callback = function() tasStopRecord();  Notify("TAS", "Recording stopped. " .. #tasFrames .. " frames.", 2) end })
Tabs.Main:AddButton({ Title = "‚ñ∂Ô∏è Play TAS",         Callback = function() tasPlay() end })
Tabs.Main:AddKeybind("TASStartBind", { Title = "Start Recording Keybind", Mode = "Toggle", Default = "", Callback = function() tasStartRecord() end })
Tabs.Main:AddKeybind("TASStopBind",  { Title = "Stop Recording Keybind",  Mode = "Toggle", Default = "", Callback = function() tasStopRecord()  end })
Tabs.Main:AddKeybind("TASPlayBind",  { Title = "Play TAS Keybind",        Mode = "Toggle", Default = "", Callback = function() tasPlay()        end })

-- =========================
-- MAIN TAB ‚Äî AUTO JUMP (original Swiss)
-- =========================
local autoJumpEnabled = false
local spaceHeld = false

Tabs.Main:AddSection("Auto Jump")
Tabs.Main:AddToggle("AutoJump", {
    Title = "Auto Jump (Hold Space)", Default = false,
    Callback = function(Value) autoJumpEnabled = Value end
})

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Space then spaceHeld = true end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then spaceHeld = false end
end)

RunService.RenderStepped:Connect(function()
    if autoJumpEnabled and spaceHeld and humanoid then
        local state = humanoid:GetState()
        if state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Landed then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- =========================
-- MAIN TAB ‚Äî MODEL LOADER (original Swiss)
-- =========================
local modelAssetId = ""
local spawnedModel = nil

Tabs.Main:AddSection("Model Loader")
Tabs.Main:AddInput("ModelAssetInput", {
    Title = "Asset ID", Default = "", Placeholder = "Enter Asset ID here...", Numeric = true, Finished = false,
    Callback = function(Value) modelAssetId = Value end
})
Tabs.Main:AddButton({
    Title = "Spawn Model",
    Callback = function()
        if modelAssetId == "" or tonumber(modelAssetId) == nil then return end
        local char = player.Character or player.CharacterAdded:Wait()
        local root = char:FindFirstChild("HumanoidRootPart"); if not root then return end
        local success, asset = pcall(function() return game:GetObjects("rbxassetid://" .. modelAssetId)[1] end)
        if not success or not asset then return end
        asset.Parent = workspace; spawnedModel = asset
        local spawnCFrame = root.CFrame * CFrame.new(0, 0, -10)
        if asset.PrimaryPart then asset:SetPrimaryPartCFrame(spawnCFrame)
        else local p = asset:FindFirstChildWhichIsA("BasePart"); if p then p.CFrame = spawnCFrame end end
    end
})
Tabs.Main:AddButton({
    Title = "Despawn Model",
    Callback = function()
        if spawnedModel and spawnedModel.Parent then spawnedModel:Destroy(); spawnedModel = nil end
    end
})

-- =========================
-- MAIN TAB ‚Äî TURNBIND (Owner Only)
-- =========================
if isOwner then
    Tabs.Main:AddSection("Turnbind")
    local turnbindEnabled = false
    local VIM = game:GetService("VirtualInputManager")
    local turnbindConn = nil; local turnbindEndConn = nil

    local function startTurnbind()
        turnbindConn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            if not turnbindEnabled then return end
            if input.KeyCode == Enum.KeyCode.A then VIM:SendKeyEvent(true, Enum.KeyCode.Left, false, game)
            elseif input.KeyCode == Enum.KeyCode.D then VIM:SendKeyEvent(true, Enum.KeyCode.Right, false, game) end
        end)
        turnbindEndConn = UserInputService.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.A then VIM:SendKeyEvent(false, Enum.KeyCode.Left, false, game)
            elseif input.KeyCode == Enum.KeyCode.D then VIM:SendKeyEvent(false, Enum.KeyCode.Right, false, game) end
        end)
    end
    local function stopTurnbind()
        if turnbindConn then turnbindConn:Disconnect(); turnbindConn = nil end
        if turnbindEndConn then turnbindEndConn:Disconnect(); turnbindEndConn = nil end
        VIM:SendKeyEvent(false, Enum.KeyCode.Left, false, game)
        VIM:SendKeyEvent(false, Enum.KeyCode.Right, false, game)
    end

    local TurnbindToggle = Tabs.Main:AddToggle("TurnbindToggle", {
        Title = "Turnbind (A = A+Left, D = D+Right)", Default = false,
        Callback = function(v) turnbindEnabled = v; if v then startTurnbind() else stopTurnbind() end end,
    })
    Tabs.Main:AddKeybind("TurnbindKeybind", {
        Title = "Turnbind Toggle Key", Mode = "Toggle", Default = "T",
        Callback = function()
            turnbindEnabled = not turnbindEnabled
            if turnbindEnabled then startTurnbind() else stopTurnbind() end
            TurnbindToggle:SetValue(turnbindEnabled)
        end,
    })
end

-- =========================
-- MAPS TAB (Import Map from Femboy Hub + original Swiss maps)
-- =========================
local importedMapModel = nil
local macdonaldMap = nil
local russiaMap = nil

-- Femboy Hub Import Map
Tabs.CustomMaps:AddSection("Import Map")
local mapNames = {"Empty","Classic","City","Dahood","TSB","Winter","Sky","BloxFruit","Hidenseek","Obby","TowerObby","McDonalds","Brookhaven","NewPlanet","JJK","Racing","Classic2","DrivingEmpire","ArenaPaint","SquidGame","GoblinMap"}
local mapIDs   = {"0","141621194","11486778910","5595565465","72569384252345","11182305499","79090364524804","11721319853","9857032925","17185279655","79328502404130","10254568133","14985811598","73308013616318","15009598974","135653057769513","12889628588","8640311613","115159842494251","8106950117","897595038"}

local function importMap(assetIdRaw)
    local idStr = tostring(assetIdRaw):match("%d+")
    if not idStr or idStr == "" then return end
    local id = tonumber(idStr)
    if importedMapModel then pcall(function() importedMapModel:Destroy() end); importedMapModel = nil end
    local ok, result = pcall(function() return InsertService:LoadAsset(id) end)
    if ok and result then
        result.Name = "SwissImportedMap"; result.Parent = workspace; importedMapModel = result
    else
        local ok2, r2 = pcall(function()
            local m = game:GetObjects("rbxassetid://"..id)
            if m and m[1] then
                local c = Instance.new("Model"); c.Name = "SwissImportedMap"
                for _, o in pairs(m) do o.Parent = c end; c.Parent = workspace; return c
            end
        end)
        if ok2 and r2 then importedMapModel = r2 end
    end
end
local function removeImportedMap()
    if importedMapModel then pcall(function() importedMapModel:Destroy() end); importedMapModel = nil end
end

Tabs.CustomMaps:AddDropdown("MapPresetDropdown", {
    Title = "Select Map & Load", Values = mapNames, Default = mapNames[1],
    Callback = function(v)
        local sel = tostring(v)
        for i, n in ipairs(mapNames) do
            if n == sel then
                if mapIDs[i] == "0" then removeImportedMap()
                else task.spawn(function() importMap(mapIDs[i]) end) end
                break
            end
        end
    end,
})
local customMapAssetID = ""
Tabs.CustomMaps:AddInput("CustomMapAssetIDInput", {
    Title = "Custom Map Asset ID", Placeholder = "e.g. 12345678", Numeric = true,
    Callback = function(v) customMapAssetID = tostring(v):match("%d+") or "" end,
})
Tabs.CustomMaps:AddButton({ Title = "üì• Import Custom Map", Callback = function()
    if customMapAssetID == "" then Notify("Import Map","‚ö†Ô∏è Please enter an Asset ID first.",3); return end
    task.spawn(function() importMap(customMapAssetID) end)
end })
Tabs.CustomMaps:AddButton({ Title = "üóëÔ∏è Remove Imported Map", Callback = function() removeImportedMap() end })

-- Original Swiss maps
Tabs.CustomMaps:AddSection("McDonald's")
Tabs.CustomMaps:AddButton({
    Title = "Spawn McDonald's Map",
    Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local root = char:FindFirstChild("HumanoidRootPart")
        local success, asset = pcall(function() return game:GetObjects("rbxassetid://10254568133")[1] end)
        if not success or not asset then return end
        asset.Parent = workspace; macdonaldMap = asset
        local spawnCFrame = root.CFrame * CFrame.new(0, 0, -10)
        if asset.PrimaryPart then asset:SetPrimaryPartCFrame(spawnCFrame)
        else local p = asset:FindFirstChildWhichIsA("BasePart"); if p then p.CFrame = spawnCFrame end end
    end
})
Tabs.CustomMaps:AddButton({
    Title = "Despawn McDonald's Map",
    Callback = function()
        if macdonaldMap and macdonaldMap.Parent then macdonaldMap:Destroy(); macdonaldMap = nil end
    end
})

Tabs.CustomMaps:AddSection("NN Russia")
Tabs.CustomMaps:AddButton({
    Title = "Spawn nn_russia",
    Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local root = char:FindFirstChild("HumanoidRootPart")
        local success, asset = pcall(function() return game:GetObjects("rbxassetid://16176397216")[1] end)
        if not success or not asset then return end
        asset.Parent = workspace; russiaMap = asset
        local spawnCFrame = root.CFrame * CFrame.new(0, 0, -10)
        if asset.PrimaryPart then asset:SetPrimaryPartCFrame(spawnCFrame)
        else local p = asset:FindFirstChildWhichIsA("BasePart"); if p then p.CFrame = spawnCFrame end end
    end
})
Tabs.CustomMaps:AddButton({
    Title = "Despawn nn_russia",
    Callback = function()
        if russiaMap and russiaMap.Parent then russiaMap:Destroy(); russiaMap = nil end
    end
})

-- =========================
-- SKY TAB (Femboy Hub version merged with Swiss)
-- =========================
local currentSkybox = nil
local SKY_FACES = {"SkyboxBk","SkyboxDn","SkyboxFt","SkyboxLf","SkyboxRt","SkyboxUp"}

local function applySkybox(assetIdRaw)
    local idStr = tostring(assetIdRaw):match("%d+")
    if not idStr or idStr == "" then return end
    local id = "rbxassetid://"..idStr
    if currentSkybox then pcall(function() currentSkybox:Destroy() end); currentSkybox = nil end
    for _, c in pairs(Lighting:GetChildren()) do if c:IsA("Sky") then c:Destroy() end end
    local ok, sky = pcall(function()
        local objs = game:GetObjects(id)
        if objs then
            for _, o in pairs(objs) do
                if o:IsA("Sky") then return o end
                for _, c in pairs(o:GetDescendants()) do if c:IsA("Sky") then return c end end
            end
        end
    end)
    if ok and sky then sky.Parent = Lighting; currentSkybox = sky
    else
        local ns = Instance.new("Sky")
        for _, f in pairs(SKY_FACES) do pcall(function() ns[f] = id end) end
        ns.Parent = Lighting; currentSkybox = ns
    end
end

local function resetSkybox()
    if currentSkybox then pcall(function() currentSkybox:Destroy() end); currentSkybox = nil end
    for _, c in pairs(Lighting:GetChildren()) do if c:IsA("Sky") then c:Destroy() end end
end

local skyNames = {"Default","Gray","Night","Anime1","Anime2","Anime3","Anime4","Femboy1","Femboy2","Femboy3","Femboy4","Aesthetic","CakeUpNight","NightVibe","Rain","Fire","Brookhaven","Space","Cloud","Space2","Space3"}
local skyIDs   = {"0","130547382131410","128839006185497","125641870562571","127770372529424","110570238374062","138349252564540","82666462942145","95142505890749","110326016107832","123826538827500","7108851308","15983996673","15983996673","12376964583","6900508449","10594723714","11675661848","116402178504134","16262385808","11336743666"}

Tabs.CustomSky:AddSection("Preset Skies")
Tabs.CustomSky:AddDropdown("SkyPresetDropdown", {
    Title = "Select Sky & Apply", Values = skyNames, Default = skyNames[1],
    Callback = function(v)
        local sel = tostring(v)
        for i, n in ipairs(skyNames) do
            if n == sel then
                if skyIDs[i] == "0" then resetSkybox()
                else task.spawn(function() applySkybox(skyIDs[i]) end) end
                break
            end
        end
    end,
})

Tabs.CustomSky:AddSection("Custom Sky")
local customSkyID = ""
Tabs.CustomSky:AddInput("CustomSkyInput", {
    Title = "Custom Sky Asset ID", Placeholder = "e.g. rbxassetid://130547382131410",
    Callback = function(v) customSkyID = tostring(v) end,
})
Tabs.CustomSky:AddButton({ Title = "‚úîÔ∏è Apply Custom Sky", Callback = function()
    if customSkyID == "" then Notify("Sky Change","‚ö†Ô∏è Please enter a Sky Asset ID first.",3); return end
    task.spawn(function() applySkybox(customSkyID) end)
end })
Tabs.CustomSky:AddButton({ Title = "üîÑ Reset Sky to Default", Callback = function() resetSkybox() end })

-- Reflective Ground (original Swiss)
local reflectEnabled = false
local reflectConnection = nil
local originalReflectances = {}
local reflectLevels = {"25", "50", "75", "100"}
local reflectLevel = 1.0

local function setGroundReflective(level)
    for part, orig in pairs(originalReflectances) do
        if part and part.Parent then part.Reflectance = orig end
    end
    originalReflectances = {}
    if level == 0 then return end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            local isCharacter = false
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Character and obj:IsDescendantOf(p.Character) then isCharacter = true; break end
            end
            if not isCharacter then originalReflectances[obj] = obj.Reflectance; obj.Reflectance = level end
        end
    end
end

Tabs.CustomSky:AddSection("Reflective Ground")
Tabs.CustomSky:AddDropdown("ReflectLevel", {
    Title = "Reflection Level", Values = reflectLevels, Default = 4,
    Callback = function(Value)
        local v = type(Value) == "table" and Value[1] or tostring(Value)
        reflectLevel = tonumber(v) / 100
        if reflectEnabled then setGroundReflective(reflectLevel) end
    end
})
Tabs.CustomSky:AddToggle("ReflectGround", {
    Title = "Reflective Ground", Default = false,
    Callback = function(Value)
        reflectEnabled = Value
        if Value then
            setGroundReflective(reflectLevel)
            reflectConnection = workspace.DescendantAdded:Connect(function(obj)
                if not reflectEnabled then return end
                if obj:IsA("BasePart") then
                    local isCharacter = false
                    for _, p in ipairs(Players:GetPlayers()) do
                        if p.Character and obj:IsDescendantOf(p.Character) then isCharacter = true; break end
                    end
                    if not isCharacter then originalReflectances[obj] = obj.Reflectance; obj.Reflectance = reflectLevel end
                end
            end)
        else
            if reflectConnection then reflectConnection:Disconnect(); reflectConnection = nil end
            setGroundReflective(0)
        end
    end
})

-- Invisible Ground (original Swiss)
local invisEnabled = false
local invisConnection = nil
local originalTransparencies = {}
local invisLevels = {"0", "25", "50", "100"}
local invisLevel = 0

local function isCharacterPart(obj)
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character and obj:IsDescendantOf(p.Character) then return true end
    end
    return false
end

local function setGroundInvis(level)
    for obj, orig in pairs(originalTransparencies) do
        if obj and obj.Parent then obj.Transparency = orig end
    end
    originalTransparencies = {}
    if level == 0 then return end
    local transparency = level / 100
    for _, obj in ipairs(workspace:GetDescendants()) do
        if (obj:IsA("BasePart") or obj:IsA("Decal") or obj:IsA("Texture")) and not isCharacterPart(obj) then
            originalTransparencies[obj] = obj.Transparency
            obj.Transparency = transparency
        end
    end
end

Tabs.CustomSky:AddSection("Invisible Ground")
Tabs.CustomSky:AddDropdown("InvisGroundLevel", {
    Title = "Invisibility Level", Values = invisLevels, Default = 1,
    Callback = function(Value)
        local v = type(Value) == "table" and Value[1] or tostring(Value)
        invisLevel = tonumber(v) or 0
        if invisEnabled then setGroundInvis(invisLevel) end
    end
})
Tabs.CustomSky:AddToggle("InvisGround", {
    Title = "Invisible Ground", Default = false,
    Callback = function(Value)
        invisEnabled = Value
        if Value then
            setGroundInvis(invisLevel)
            invisConnection = workspace.DescendantAdded:Connect(function(obj)
                if not invisEnabled then return end
                if (obj:IsA("BasePart") or obj:IsA("Decal") or obj:IsA("Texture")) and not isCharacterPart(obj) then
                    originalTransparencies[obj] = obj.Transparency
                    obj.Transparency = invisLevel / 100
                end
            end)
        else
            if invisConnection then invisConnection:Disconnect(); invisConnection = nil end
            setGroundInvis(0)
        end
    end
})

-- =========================
-- EMOTE CHANGER TAB (original Swiss)
-- =========================
local evadeEmotes = {
    "Addendum","Aerobics","AngelicWings","AprilShower","Arose","AvariceLounge",
    "BeachChairLounge","Beg","Bhop","BobointheBox","BoldMarch","Boneless",
    "BoogieDown","Breakdown","BringItAround","Broom","BumperKart",
    "California","CampfireDoze","Caramelldansen","Carlton","CasualSurfing",
    "Catdown","Catjam","CatParty","ChristmasBoogie","Clap","ClassicDance",
    "ClassicJeep","ClassicStride","ClubDance","CompanyMan","Conga","CozyChair",
    "Crabby","CrouchDance","CuerdasDelAlma","CyberBroom",
    "DeadBoneStride","Distraction","DogParty","DreamyCloud","DuckyMarch","DynastyDrumming",
    "Epicaricacy",
    "Facepalm","FastFoodDelight","Fazbore","FireworkBlast","FlashingLights",
    "Flexing","FlyingFish","FlyingSleigh","Freestyle","FreshFlop","FrightFunk","FrostDrake",
    "Gangnam","GhastlyGrimoire","GhoulishGalleon","Gmod","GoldRitual","GoofyStride",
    "GraveRider","Griddy","Gyrating",
    "HarpRecital","HeadlessBaller","HeadlessHorseman","Heaventaker","Hired","HoveringCrystal",
    "IceFishing","Infectious","IrishJig",
    "Kickback",
    "LDance","LemonadeStand","LineDance","LittleJiggy","LunarParty",
    "M3GANDance","Macarena","ManyFans","MaracaTime","Marching","MarchShowcase",
    "MariachiBand","Mashle","Moonwalk",
    "Nizmoo","Nostalgia","Nutcracker",
    "ParkerPride","PawsClaws","PBJT","PonPon","PoolTime","Popipopi","PotionMash","PumpItUp",
    "RainingTacos","Rambunctious","Reanimated","Robot","RobotM3GAN","Rocket",
    "RockingHorse","RockinStride","RowBoat","RudolphMount","RushinAround","RussianDance",
    "SantaMech","ScorchedEarth","SeeTinh","SerenePerch","SeriousMarch","Sit",
    "SkateboardStroll","SkiSpree","SledDrifting","Sleep","Sleepybara","Smile","Smug",
    "SnowAngel","SnowmanConstruction","SnowmobileCruise","SolarBike","SolarConqueror",
    "SolarSlayer","SpiritedAway","SpookyTime","StarPower","Stride","SummerDays","SwagWalk",
    "Tank","TexasStyle","Thriller","TouchGrass","ToyTrainRide","TPose","TurkeyJockey","TurtleHobble",
    "ValentineComputer",
    "WerewolfHowl","WindupDance","WindUpPose","WinterMelody","WinterRide","Writhing",
    "Xylobone",
    "ZenSerenity","ZombieStride"
}

local fromEmote = evadeEmotes[1]
local toEmote = evadeEmotes[2]
local backups = {}
local activeSwaps = {}
local emotesFolder = ReplicatedStorage:WaitForChild("Items", 10)
emotesFolder = emotesFolder and emotesFolder:WaitForChild("Emotes", 10)

local function getEmoteFolder(name)
    if not emotesFolder then return nil end
    return emotesFolder:FindFirstChild(name)
end

local function resolveValue(v)
    if type(v) == "table" then return v[1] end
    return tostring(v)
end

local function findEmote(input)
    local lower = input:lower():gsub("%s+", "")
    if lower == "" then return nil end
    for _, e in ipairs(evadeEmotes) do if e:lower() == lower then return e end end
    for _, e in ipairs(evadeEmotes) do if e:lower():find(lower, 1, true) then return e end end
    return nil
end

local function swapEmote(fromName, toName)
    local fromFolder = getEmoteFolder(fromName)
    local toFolder = getEmoteFolder(toName)
    if not fromFolder or not toFolder then return end
    if not backups[fromName] then backups[fromName] = fromFolder.Name end
    local toClone = toFolder:Clone()
    toClone.Name = fromName; toClone.Parent = emotesFolder
    fromFolder.Name = fromName .. "_SWAPPED_BACKUP"
    activeSwaps[fromName] = toName
end

local function resetEmote(fromName)
    if not backups[fromName] then return end
    local swapped = emotesFolder:FindFirstChild(fromName)
    if swapped then swapped.Name = fromName .. "_TEMP_DELETE"; swapped:Destroy() end
    task.wait(0.05)
    local backup = emotesFolder:FindFirstChild(fromName .. "_SWAPPED_BACKUP")
    if backup then backup.Name = fromName end
    backups[fromName] = nil; activeSwaps[fromName] = nil
end

player.CharacterAdded:Connect(function()
    if next(activeSwaps) then
        task.wait(1)
        for fromName, toName in pairs(activeSwaps) do
            local fromFolder = getEmoteFolder(fromName)
            local toFolder = getEmoteFolder(toName)
            if fromFolder and toFolder then
                local toClone = toFolder:Clone()
                toClone.Name = fromName; toClone.Parent = emotesFolder
                fromFolder.Name = fromName .. "_SWAPPED_BACKUP"
            end
        end
    end
end)

Tabs.EmoteChanger:AddSection("Swap Settings")
Tabs.EmoteChanger:AddInput("EmoteFromInput", {
    Title = "From (Emote to Replace)", Default = "", Placeholder = "Type emote name e.g. BoldMarch...", Finished = false,
    Callback = function(Value) local found = findEmote(Value); if found then fromEmote = found end end
})
Tabs.EmoteChanger:AddInput("EmoteToInput", {
    Title = "To (Replace With)", Default = "", Placeholder = "Type emote name e.g. RockinStride...", Finished = false,
    Callback = function(Value) local found = findEmote(Value); if found then toEmote = found end end
})
Tabs.EmoteChanger:AddSection("Or Pick From Dropdown (A-Z)")
Tabs.EmoteChanger:AddDropdown("EmoteFromDropdown", {
    Title = "From (Dropdown)", Values = evadeEmotes, Default = 1,
    Callback = function(Value) fromEmote = resolveValue(Value) end
})
Tabs.EmoteChanger:AddDropdown("EmoteToDropdown", {
    Title = "To (Dropdown)", Values = evadeEmotes, Default = 1,
    Callback = function(Value) toEmote = resolveValue(Value) end
})
Tabs.EmoteChanger:AddSection("Controls")
Tabs.EmoteChanger:AddButton({ Title = "Apply Swap",          Callback = function() local f = resolveValue(fromEmote); local t = resolveValue(toEmote); if f ~= t then swapEmote(f, t) end end })
Tabs.EmoteChanger:AddButton({ Title = "Reset Swapped Emote", Callback = function() resetEmote(resolveValue(fromEmote)) end })
Tabs.EmoteChanger:AddButton({ Title = "Reset All Emotes",    Callback = function() for name, _ in pairs(backups) do resetEmote(name) end end })

-- =========================
-- WHEEL VISUAL REPLACEMENT (from Femboy Hub)
-- =========================
local ec_normalCache2 = {}
local ec_nameCache2 = {}
local ec_emoteModelScript = nil
local ec_originalEmoteData = {}
local ec_emoteDataSaved = false
local ec_emoteFrame = nil
local ec_replacementEnabled = false
local ec_wheelSlots = {}
local ec_selectedWheelSlot = 1
for i = 1,12 do ec_wheelSlots[i] = {trigger="", visual=""} end

local function ec_norm(text)
    if not text then return "" end
    if not ec_normalCache2[text] then ec_normalCache2[text] = string.lower(text:gsub("%s+","")) end
    return ec_normalCache2[text]
end

local function ec_getEmoteFrame()
    local pg = player.PlayerGui; if not pg then return nil end
    local shared = pg:FindFirstChild("Shared"); local hud = shared and shared:FindFirstChild("HUD")
    local interactors = hud and hud:FindFirstChild("Interactors"); local popups = interactors and interactors:FindFirstChild("Popups")
    return popups and popups:FindFirstChild("Emote")
end

local function ec_findEmoteModelScript()
    if ec_emoteModelScript then return ec_emoteModelScript end
    for _, s in pairs(player.PlayerScripts:GetDescendants()) do if s.Name == "EmoteModel" then ec_emoteModelScript = s; return s end end
    local ef2 = ReplicatedStorage:FindFirstChild("Items"); ef2 = ef2 and ef2:FindFirstChild("Emotes")
    if ef2 then for _, s in pairs(ef2:GetDescendants()) do if s.Name == "EmoteModel" then ec_emoteModelScript = s; return s end end end
    return nil
end

local function ec_findModuleByDisplayName(displayName)
    if displayName == "NONE" or not displayName then return nil end
    if ec_nameCache2[displayName] ~= nil then return ec_nameCache2[displayName] end
    local ef2 = ReplicatedStorage:FindFirstChild("Items"); if not ef2 then ec_nameCache2[displayName]=nil; return nil end
    ef2 = ef2:FindFirstChild("Emotes"); if not ef2 then ec_nameCache2[displayName]=nil; return nil end
    local norm = ec_norm(displayName)
    for _, m in pairs(ef2:GetChildren()) do
        local ok, data = pcall(require, m)
        if ok and data then
            local dn = data.AppearanceInfo and (data.AppearanceInfo.NameShorted or data.AppearanceInfo.Name)
            if dn and ec_norm(dn) == norm then ec_nameCache2[displayName] = m.Name; return m.Name end
        end
    end
    ec_nameCache2[displayName] = nil; return nil
end

local function ec_saveOriginalEmoteData(frame)
    if not frame then return end; ec_originalEmoteData = {}
    local function saveSlot(slot, key)
        if not slot then return end; local tl = slot:FindFirstChild("TextLabel")
        if tl then ec_originalEmoteData[key] = {displayText=tl.Text, emoteName=ec_findModuleByDisplayName(tl.Text) or tl.Text} end
    end
    local w1 = frame:FindFirstChild("Wheel"); local w2 = frame:FindFirstChild("Wheel2")
    if w1 then for i=1,6 do saveSlot(w1:FindFirstChild("Emote"..i),"Wheel_Emote"..i) end end
    if w2 then for i=1,6 do saveSlot(w2:FindFirstChild("Emote"..i),"Wheel2_Emote"..i) end end
    ec_emoteDataSaved = true
end

local function ec_restoreOriginalEmotes()
    ec_findEmoteModelScript()
    if not ec_emoteModelScript or not ec_emoteFrame then return end
    local emf = require(ec_emoteModelScript)
    local ef2 = ReplicatedStorage:FindFirstChild("Items"); ef2 = ef2 and ef2:FindFirstChild("Emotes"); if not ef2 then return end
    local function processSlot(slot, key)
        if not slot then return end
        local tl = slot:FindFirstChild("TextLabel"); local vf = slot:FindFirstChild("ViewportFrame")
        if tl and vf then
            local orig = ec_originalEmoteData[key]
            if orig then
                if vf:FindFirstChild("WorldModel") then vf.WorldModel:Destroy() end
                if orig.displayText ~= "NONE" and orig.emoteName then
                    local em = ef2:FindFirstChild(orig.emoteName)
                    if em then emf(vf, orig.emoteName) end; tl.Text = orig.displayText
                else tl.Text = "NONE" end
            end
        end
    end
    local w1 = ec_emoteFrame:FindFirstChild("Wheel"); local w2 = ec_emoteFrame:FindFirstChild("Wheel2")
    if w1 then for i=1,6 do processSlot(w1:FindFirstChild("Emote"..i),"Wheel_Emote"..i) end end
    if w2 then for i=1,6 do processSlot(w2:FindFirstChild("Emote"..i),"Wheel2_Emote"..i) end end
end

local function ec_replaceEmotesFrame()
    if not ec_replacementEnabled or not ec_emoteDataSaved or not ec_emoteFrame then return end
    ec_findEmoteModelScript(); if not ec_emoteModelScript then return end
    local emf = require(ec_emoteModelScript)
    local ef2 = ReplicatedStorage:FindFirstChild("Items"); ef2 = ef2 and ef2:FindFirstChild("Emotes"); if not ef2 then return end
    local function processSlot(slot, wheelName, i)
        if not slot then return end; local tl = slot:FindFirstChild("TextLabel"); if not tl then return end
        local norm = ec_norm(tl.Text)
        for j = 1,12 do
            local s = ec_wheelSlots[j]
            if s.trigger ~= "" and s.visual ~= "" and norm == ec_norm(s.trigger) then
                local vf = slot:FindFirstChild("ViewportFrame")
                if vf then
                    local rm = ef2:FindFirstChild(s.visual)
                    if rm then
                        local key = wheelName.."_Emote"..i
                        if not ec_originalEmoteData[key] then
                            ec_originalEmoteData[key] = {displayText=tl.Text, emoteName=ec_findModuleByDisplayName(tl.Text) or tl.Text}
                        end
                        if vf:FindFirstChild("WorldModel") then vf.WorldModel:Destroy() end
                        local ok, td = pcall(require, rm)
                        if ok and td then
                            local dn = td.AppearanceInfo and (td.AppearanceInfo.NameShorted or td.AppearanceInfo.Name)
                            emf(vf, s.visual); tl.Text = dn or s.visual
                        end
                    end
                end; break
            end
        end
    end
    local w1 = ec_emoteFrame:FindFirstChild("Wheel"); local w2 = ec_emoteFrame:FindFirstChild("Wheel2")
    if w1 then for i=1,6 do processSlot(w1:FindFirstChild("Emote"..i),"Wheel",i) end end
    if w2 then for i=1,6 do processSlot(w2:FindFirstChild("Emote"..i),"Wheel2",i) end end
end

Tabs.EmoteChanger:AddSection("Wheel Visual Replacement")
Tabs.EmoteChanger:AddParagraph({ Title = "How to use", Content = "‚ë† Open emote wheel in-game\n‚ë° Set Trigger (the emote in the slot) and Visual (what to show instead)\n‚ë¢ Enable, then click Apply" })
Tabs.EmoteChanger:AddDropdown("WheelSlotSelector", {
    Title = "Slot (1‚Äì12)", Values = {"1","2","3","4","5","6","7","8","9","10","11","12"}, Default = "1",
    Callback = function(v) ec_selectedWheelSlot = tonumber(v) or 1 end,
})
Tabs.EmoteChanger:AddInput("WheelTriggerInput", {
    Title = "Trigger Emote (name in wheel slot)", Placeholder = "e.g. BoldMarch",
    Callback = function(v) ec_wheelSlots[ec_selectedWheelSlot].trigger = v:gsub("^%s*(.-)%s*$","%1") end,
})
Tabs.EmoteChanger:AddInput("WheelVisualInput", {
    Title = "Show As (visual replacement)", Placeholder = "e.g. RockinStride",
    Callback = function(v) ec_wheelSlots[ec_selectedWheelSlot].visual = v:gsub("^%s*(.-)%s*$","%1") end,
})
Tabs.EmoteChanger:AddToggle("WheelReplaceToggle", {
    Title = "Enable Wheel Visual Replacement", Default = false,
    Callback = function(v)
        ec_replacementEnabled = v
        if ec_emoteFrame and ec_emoteDataSaved then
            ec_restoreOriginalEmotes()
            if v then ec_replaceEmotesFrame() end
        end
    end,
})
Tabs.EmoteChanger:AddButton({ Title = "‚úîÔ∏è Apply Wheel Mapping", Callback = function()
    ec_emoteFrame = ec_getEmoteFrame()
    if not ec_emoteFrame then Notify("Wheel Replace","‚ö†Ô∏è Open your emote wheel first!",4); return end
    ec_findEmoteModelScript()
    ec_saveOriginalEmoteData(ec_emoteFrame)
    ec_restoreOriginalEmotes()
    if ec_replacementEnabled then ec_replaceEmotesFrame() end
    Notify("Wheel Replace","‚úÖ Mapping applied!",3)
end })
Tabs.EmoteChanger:AddButton({ Title = "üîÑ Restore Wheel to Original", Callback = function()
    if ec_emoteFrame then ec_restoreOriginalEmotes(); Notify("Wheel Replace","‚úÖ Wheel restored.",3)
    else Notify("Wheel Replace","‚ö†Ô∏è No wheel captured yet.",3) end
end })
Tabs.EmoteChanger:AddButton({ Title = "üóëÔ∏è Clear All Wheel Slots", Callback = function()
    for i=1,12 do ec_wheelSlots[i] = {trigger="", visual=""} end
    ec_normalCache2 = {}; ec_nameCache2 = {}
    Notify("Wheel Replace","All slots cleared.",2)
end })

-- =========================
-- EMOTE RENAMER
-- =========================
local ec_renamedEmotes = {}
local ec_renameTarget = ""
local ec_renameNewName = ""

local function ec_applyRenames()
    local frame = ec_getEmoteFrame()
    if not frame then Notify("Emote Renamer","‚ö†Ô∏è Open your emote wheel first!",4); return end
    local function renameSlot(slot)
        if not slot then return end
        local tl = slot:FindFirstChild("TextLabel"); if not tl then return end
        for emoteName, newName in pairs(ec_renamedEmotes) do
            if ec_norm(tl.Text) == ec_norm(emoteName) then tl.Text = newName end
        end
    end
    local w1 = frame:FindFirstChild("Wheel"); local w2 = frame:FindFirstChild("Wheel2")
    if w1 then for i=1,6 do renameSlot(w1:FindFirstChild("Emote"..i)) end end
    if w2 then for i=1,6 do renameSlot(w2:FindFirstChild("Emote"..i)) end end
    Notify("Emote Renamer","‚úÖ Names applied to wheel!",3)
end

local function ec_resetRenames()
    ec_renamedEmotes = {}
    if ec_emoteFrame and ec_emoteDataSaved then ec_restoreOriginalEmotes() end
    Notify("Emote Renamer","‚úÖ All names reset.",2)
end

Tabs.EmoteChanger:AddSection("Emote Renamer")
Tabs.EmoteChanger:AddParagraph({ Title = "How to use", Content = "Pick an emote, type a new display name, add it, then apply while your wheel is open." })
Tabs.EmoteChanger:AddDropdown("RenameSlotDropdown", {
    Title = "Pick Emote to Rename", Values = evadeEmotes, Default = 1,
    Callback = function(v) ec_renameTarget = resolveValue(v) end,
})
Tabs.EmoteChanger:AddInput("RenameNewNameInput", {
    Title = "New Display Name", Placeholder = "e.g. My Cool Emote",
    Callback = function(v) ec_renameNewName = v:gsub("^%s*(.-)%s*$","%1") end,
})
Tabs.EmoteChanger:AddButton({ Title = "‚ûï Add Rename", Callback = function()
    if ec_renameTarget == "" or ec_renameNewName == "" then Notify("Emote Renamer","‚ö†Ô∏è Pick an emote and enter a name.",3); return end
    ec_renamedEmotes[ec_renameTarget] = ec_renameNewName
    Notify("Emote Renamer",ec_renameTarget.." ‚Üí "..ec_renameNewName,3)
end })
Tabs.EmoteChanger:AddButton({ Title = "‚úîÔ∏è Apply All Renames", Callback = function()
    if not next(ec_renamedEmotes) then Notify("Emote Renamer","‚ö†Ô∏è No renames added yet.",3); return end
    ec_applyRenames()
end })
Tabs.EmoteChanger:AddButton({ Title = "üîÑ Reset All Renames", Callback = function() ec_resetRenames() end })

-- =========================
-- VISUAL TAB (original Swiss)
-- =========================
local colorCorrection = nil
Tabs.CoolStuff:AddSection("Color Correction")
Tabs.CoolStuff:AddToggle("ColorCorrectionToggle", {
    Title = "Color Correction", Default = false,
    Callback = function(Value)
        if Value then colorCorrection = Instance.new("ColorCorrectionEffect"); colorCorrection.Parent = Lighting
        else if colorCorrection then colorCorrection:Destroy(); colorCorrection = nil end end
    end
})
Tabs.CoolStuff:AddSlider("BrightnessSlider", { Title = "Brightness", Default = 0, Min = -1, Max = 1, Rounding = 1, Callback = function(Value) if colorCorrection then colorCorrection.Brightness = Value end end })
Tabs.CoolStuff:AddSlider("ContrastSlider",   { Title = "Contrast",   Default = 0, Min = -1, Max = 1, Rounding = 1, Callback = function(Value) if colorCorrection then colorCorrection.Contrast = Value end end })
Tabs.CoolStuff:AddSlider("SaturationSlider", { Title = "Saturation", Default = 0, Min = -1, Max = 1, Rounding = 1, Callback = function(Value) if colorCorrection then colorCorrection.Saturation = Value end end })

Tabs.CoolStuff:AddSection("Shaders")
local shaderGui = nil
local shaderEnabled = false
local shaderPresets = {
    ["Cinematic"]    = { vignette=0.5, saturation=1.3, brightness=0.05, contrast=1.1, grain=0.03, aberration=2 },
    ["Vintage"]      = { vignette=0.7, saturation=0.6, brightness=-0.05, contrast=1.2, grain=0.06, aberration=3 },
    ["Vibrant"]      = { vignette=0.3, saturation=1.8, brightness=0.1, contrast=1.0, grain=0.01, aberration=1 },
    ["Night Vision"] = { vignette=0.8, saturation=0.0, brightness=0.2, contrast=1.5, grain=0.08, aberration=0 },
    ["Dreamy"]       = { vignette=0.4, saturation=1.2, brightness=0.15, contrast=0.9, grain=0.02, aberration=4 },
}

local function removeShaders()
    local playerGui = player:WaitForChild("PlayerGui")
    local existing = playerGui:FindFirstChild("SwissShaders")
    if existing then existing:Destroy() end
end

local function applyShader(preset)
    removeShaders()
    local playerGui = player:WaitForChild("PlayerGui")
    local gui = Instance.new("ScreenGui"); gui.Name = "SwissShaders"; gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling; gui.Parent = playerGui; shaderGui = gui
    if preset.vignette and preset.vignette > 0 then
        local vignette = Instance.new("ImageLabel"); vignette.Size = UDim2.fromScale(1,1)
        vignette.BackgroundTransparency = 1; vignette.Image = "rbxassetid://1380877666"
        vignette.ImageColor3 = Color3.fromRGB(0,0,0); vignette.ImageTransparency = 1 - preset.vignette
        vignette.ScaleType = Enum.ScaleType.Stretch; vignette.ZIndex = 10; vignette.Parent = gui
    end
    if preset.aberration and preset.aberration > 0 then
        local aberrationFrame = Instance.new("Frame"); aberrationFrame.Size = UDim2.fromScale(1,1)
        aberrationFrame.BackgroundTransparency = 1; aberrationFrame.ZIndex = 9; aberrationFrame.Parent = gui
        local colors = {
            {Color3.fromRGB(255,0,0), 0.85, UDim2.new(0,preset.aberration,0,0)},
            {Color3.fromRGB(0,255,0), 0.85, UDim2.new(0,0,0,0)},
            {Color3.fromRGB(0,0,255), 0.85, UDim2.new(0,-preset.aberration,0,0)},
        }
        for _, data in ipairs(colors) do
            local frame = Instance.new("Frame"); frame.Size = UDim2.fromScale(1,1); frame.Position = data[3]
            frame.BackgroundColor3 = data[1]; frame.BackgroundTransparency = data[2]
            frame.BorderSizePixel = 0; frame.ZIndex = 9; frame.Parent = aberrationFrame
        end
    end
    if preset.grain and preset.grain > 0 then
        local grainLabel = Instance.new("ImageLabel"); grainLabel.Size = UDim2.fromScale(1,1)
        grainLabel.BackgroundTransparency = 1; grainLabel.Image = "rbxassetid://5154854688"
        grainLabel.ImageTransparency = 1 - preset.grain; grainLabel.ZIndex = 11; grainLabel.Parent = gui
        task.spawn(function()
            while shaderEnabled and grainLabel and grainLabel.Parent do
                grainLabel.TileSize = UDim2.new(0, math.random(50,150), 0, math.random(50,150))
                grainLabel.Position = UDim2.new(0, math.random(-10,10), 0, math.random(-10,10))
                task.wait(0.05)
            end
        end)
    end
    for _, obj in pairs(Lighting:GetChildren()) do if obj:IsA("ColorCorrectionEffect") and obj.Name == "SwissColorCorrection" then obj:Destroy() end end
    if preset.saturation or preset.brightness or preset.contrast then
        local cc = Instance.new("ColorCorrectionEffect"); cc.Name = "SwissColorCorrection"
        cc.Saturation = (preset.saturation or 1) - 1; cc.Brightness = preset.brightness or 0
        cc.Contrast = (preset.contrast or 1) - 1; cc.Parent = Lighting
    end
end

Tabs.CoolStuff:AddDropdown("ShaderPreset", {
    Title = "Shader Preset", Values = {"Cinematic","Vintage","Vibrant","Night Vision","Dreamy"}, Default = 1,
    Callback = function(Value)
        local v = type(Value) == "table" and Value[1] or tostring(Value)
        if shaderEnabled then applyShader(shaderPresets[v]) end
    end
})
Tabs.CoolStuff:AddToggle("ShaderToggle", {
    Title = "Enable Shader", Default = false,
    Callback = function(Value)
        shaderEnabled = Value
        if Value then
            local sel = type(Fluent.Options.ShaderPreset.Value) == "table" and Fluent.Options.ShaderPreset.Value[1] or tostring(Fluent.Options.ShaderPreset.Value)
            applyShader(shaderPresets[sel] or shaderPresets["Cinematic"])
        else
            removeShaders()
            for _, obj in pairs(Lighting:GetChildren()) do if obj.Name == "SwissColorCorrection" then obj:Destroy() end end
        end
    end
})

Tabs.CoolStuff:AddSection("Neon World")
Tabs.CoolStuff:AddToggle("NeonWorld", {
    Title = "Neon World", Default = false,
    Callback = function(Value)
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                local isChar = false
                for _, p in ipairs(Players:GetPlayers()) do if p.Character and obj:IsDescendantOf(p.Character) then isChar = true; break end end
                if not isChar then obj.Material = Value and Enum.Material.Neon or Enum.Material.SmoothPlastic end
            end
        end
    end
})

Tabs.CoolStuff:AddSection("Ambient")
Tabs.CoolStuff:AddDropdown("AmbientPreset", {
    Title = "Ambient Color Preset",
    Values = {"Default","Red","Blue","Green","Purple","Orange","Pink","Night","Golden Hour"}, Default = 1,
    Callback = function(Value)
        local v = type(Value) == "table" and Value[1] or tostring(Value)
        local ambientMap = {
            ["Default"]     = {Color3.fromRGB(127,127,127), Color3.fromRGB(127,127,127)},
            ["Red"]         = {Color3.fromRGB(255,50,50),   Color3.fromRGB(200,0,0)},
            ["Blue"]        = {Color3.fromRGB(50,50,255),   Color3.fromRGB(0,0,200)},
            ["Green"]       = {Color3.fromRGB(50,255,50),   Color3.fromRGB(0,200,0)},
            ["Purple"]      = {Color3.fromRGB(150,0,255),   Color3.fromRGB(100,0,200)},
            ["Orange"]      = {Color3.fromRGB(255,150,0),   Color3.fromRGB(200,100,0)},
            ["Pink"]        = {Color3.fromRGB(255,100,200), Color3.fromRGB(200,50,150)},
            ["Night"]       = {Color3.fromRGB(10,10,40),    Color3.fromRGB(5,5,20)},
            ["Golden Hour"] = {Color3.fromRGB(255,180,50),  Color3.fromRGB(220,120,0)},
        }
        local colors = ambientMap[v]
        if colors then Lighting.Ambient = colors[1]; Lighting.OutdoorAmbient = colors[2] end
    end
})

-- =========================
-- OWNER TAB (original Swiss)
-- =========================
if isOwner then
    Tabs.Owner:AddSection("üëë Owner Panel")
    Tabs.Owner:AddParagraph({ Title = "Welcome back, kxnzlieeee!", Content = "You have full access to all owner-exclusive features below." })

    local ownerSpeed = 16
    Tabs.Owner:AddSection("Speed Hack")
    Tabs.Owner:AddToggle("SpeedHack", { Title = "Speed Hack", Default = false,
        Callback = function(Value)
            local char = player.Character or player.CharacterAdded:Wait()
            local hum = char:FindFirstChild("Humanoid")
            if hum then hum.WalkSpeed = Value and ownerSpeed or 16 end
        end
    })
    Tabs.Owner:AddSlider("SpeedValue", { Title = "Walk Speed", Default = 16, Min = 16, Max = 500, Rounding = 0,
        Callback = function(Value)
            ownerSpeed = Value
            local char = player.Character or player.CharacterAdded:Wait()
            local hum = char:FindFirstChild("Humanoid")
            if hum and Fluent.Options.SpeedHack.Value then hum.WalkSpeed = Value end
        end
    })

    local ownerJump = 50
    Tabs.Owner:AddSection("Jump Power")
    Tabs.Owner:AddToggle("JumpHack", { Title = "Jump Power Hack", Default = false,
        Callback = function(Value)
            local char = player.Character or player.CharacterAdded:Wait()
            local hum = char:FindFirstChild("Humanoid")
            if hum then hum.JumpPower = Value and ownerJump or 50 end
        end
    })
    Tabs.Owner:AddSlider("JumpValue", { Title = "Jump Power", Default = 50, Min = 50, Max = 500, Rounding = 0,
        Callback = function(Value)
            ownerJump = Value
            local char = player.Character or player.CharacterAdded:Wait()
            local hum = char:FindFirstChild("Humanoid")
            if hum and Fluent.Options.JumpHack.Value then hum.JumpPower = Value end
        end
    })

    Tabs.Owner:AddSection("Teleport")
    Tabs.Owner:AddButton({ Title = "Teleport to Spawn", Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrpO = char:FindFirstChild("HumanoidRootPart")
        if hrpO then hrpO.CFrame = CFrame.new(0, 10, 0) end
    end })

    Tabs.Owner:AddSection("Ghost Mode")
    Tabs.Owner:AddToggle("GhostMode", { Title = "Ghost Mode (No Collision)", Default = false,
        Callback = function(Value)
            local char = player.Character or player.CharacterAdded:Wait()
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then part.CanCollide = not Value end
            end
        end
    })

    Tabs.Owner:AddSection("Misc")
    Tabs.Owner:AddButton({ Title = "Reset Character", Callback = function()
        local hum = player.Character and player.Character:FindFirstChild("Humanoid")
        if hum then hum.Health = 0 end
    end })

    local bhopEnabled = false; local bhopConnection = nil
    Tabs.Owner:AddSection("Bunny Hop")
    Tabs.Owner:AddToggle("BhopToggle", { Title = "Bunny Hop", Default = false,
        Callback = function(Value)
            bhopEnabled = Value
            if Value then
                bhopConnection = RunService.Heartbeat:Connect(function()
                    if not bhopEnabled then return end
                    local char = player.Character; if not char then return end
                    local hum = char:FindFirstChild("Humanoid"); local hrpO = char:FindFirstChild("HumanoidRootPart")
                    if not hum or not hrpO then return end
                    if hum:GetState() == Enum.HumanoidStateType.Landed then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
                end)
            else if bhopConnection then bhopConnection:Disconnect(); bhopConnection = nil end end
        end
    })
    Tabs.Owner:AddKeybind("BhopKeybind", { Title = "Bunny Hop Keybind", Mode = "Toggle", Default = "V",
        Callback = function() local toggle = Fluent.Options.BhopToggle; toggle:SetValue(not toggle.Value) end
    })

    local strafeEnabled = false; local strafeConnection = nil; local strafeMultiplier = 1.3
    Tabs.Owner:AddSection("Strafe Assistant")
    Tabs.Owner:AddToggle("StrafeToggle", { Title = "Strafe Assistant", Default = false,
        Callback = function(Value)
            strafeEnabled = Value
            if Value then
                strafeConnection = RunService.Heartbeat:Connect(function()
                    if not strafeEnabled then return end
                    local char = player.Character; if not char then return end
                    local hrpO = char:FindFirstChild("HumanoidRootPart"); local hum = char:FindFirstChild("Humanoid")
                    if not hrpO or not hum or hum.Health <= 0 then return end
                    if UserInputService:IsKeyDown(Enum.KeyCode.A) or UserInputService:IsKeyDown(Enum.KeyCode.D) then
                        local vel = hrpO.AssemblyLinearVelocity
                        hrpO.AssemblyLinearVelocity = Vector3.new(vel.X*strafeMultiplier, vel.Y, vel.Z*strafeMultiplier)
                    end
                end)
            else if strafeConnection then strafeConnection:Disconnect(); strafeConnection = nil end end
        end
    })
    Tabs.Owner:AddSlider("StrafeMultiplier", { Title = "Strafe Boost", Default = 13, Min = 10, Max = 20, Rounding = 0,
        Callback = function(Value) strafeMultiplier = Value / 10 end
    })

    local antiAfkConnection = nil
    Tabs.Owner:AddSection("Anti AFK")
    Tabs.Owner:AddToggle("AntiAfkToggle", { Title = "Anti AFK", Default = false,
        Callback = function(Value)
            if Value then
                antiAfkConnection = RunService.Heartbeat:Connect(function()
                    local VIM = game:GetService("VirtualInputManager")
                    VIM:SendKeyEvent(true, Enum.KeyCode.ButtonL3, false, game)
                    VIM:SendKeyEvent(false, Enum.KeyCode.ButtonL3, false, game)
                end)
            else if antiAfkConnection then antiAfkConnection:Disconnect(); antiAfkConnection = nil end end
        end
    })
else
    Tabs.Owner:AddSection("üîí Restricted")
    Tabs.Owner:AddParagraph({ Title = "Access Denied", Content = "This tab is reserved for the owner only." })
    Tabs.Owner:AddParagraph({ Title = "Detected User", Content = player.DisplayName .. " (@" .. player.Name .. ")" })
end

-- =========================
-- SETTINGS TAB
-- =========================
local rainbowThemeEnabled = false
Tabs.Settings:AddSection("Rainbow Theme")
Tabs.Settings:AddToggle("RainbowTheme", { Title = "Rainbow UI Theme", Default = false,
    Callback = function(Value)
        rainbowThemeEnabled = Value
        if Value then
            task.spawn(function()
                local hue = 0
                while rainbowThemeEnabled do
                    hue = (hue + 0.002) % 1
                    local color = Color3.fromHSV(hue, 1, 1)
                    pcall(function() Fluent:SetAccentColor(color) end)
                    task.wait(0.05)
                end
            end)
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
InterfaceManager:SetFolder("SwissHub")
SaveManager:SetFolder("SwissHub/configs")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
